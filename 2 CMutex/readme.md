#实验简介

本实验讨论临界区问题及其解决方案。实验首先创建两个共享数据资源的并发线程。在没有同步控制机制的情况下，我们将看到某些异常现象。针对观察到的现象，本实验采用两套解决方案：

利用windows的mutex机制

采用软件方案

然后比较这两种方案的性能优劣。

#实验内容

制造混乱

创建两个线程t1和t2，改变accnt1和accnt2的值，可以看到两个线程之间没有同步，造成了混乱。在第9322次运行时，某线程中的accnt1值为153634968，而accnt2的值为-153405745，绝对值不同，证明造成了混乱。此时此线程已经跳出while循环，没有代码可以执行，故后续只有另一线程在运行，且读取的数值是此线程改变accnt数值之前的数值，同时加减一个数，两accnt数值一定相等，故继续无限运行下去，不会跳出while循环。

Mutex方案

使用Windows提供的mutex信号量来实现同步机制。定义全局的mutex，在main中初始化，在线程中读取数据之前加锁wait，在判断完两值是否相等后解锁release。每执行50000次打印一次counter的值，以证明程序在运行。可以看到很长一段时间内，两线程都在同步状态，没有值不等跳出循环的现象。

假设把加锁和开锁操作分别放置在第一个写操作之前和第二个写操作之后，能否实现临界区的保护，为什么？
不能实现保护。由于读取数值给了tmp，此时tmp数值是当前数值，当更改tmp写回accnt时，另一个线程可能已经完成了修改，accnt的数值和tmp读取时的数值可能不一致，导致丢失同步，读脏数据。

软件方案

使用自己编写的程序来实现线程同步。按照实验指导中给出的框架，编写程序。设置c1,c2,will_wait三个变量，当线程1在运行时，c1置1，will_wait置1，如果此时c2为1，且will_wait为1，则线程1等待，否则读取accnt的值并继续剩余代码。线程2同理。
此外，当accnt失去同步时，将打印当前的counter及accnt的值；每执行50000次后，打印一次counter的值及线程号。

第一个线程写入后打印“+”，第二个线程写入后打印“*”，可以证明两个线程在交替运行，而不是仅有一个进程在执行代码。

使用软件方案，运行500000次，平均运行时为56.4

使用mutex方案，运行500000次用时，平均用时为3565.6。

由此可见，使用软件方案的运行时远小于使用mutex方案，系统所提供的mutex是一个体量比较庞大的信号量，而自己编写的简单程序并不需要使用如此复杂的信号量来实现进程同步，故软件方案用三个int型变量来实现，不仅系统消耗小，而且运行快。

为什么把变量will_wait的值设置为i

如果在进入此线程之前，另一线程没有运行完毕且释放锁，那么此线程应当“will wait”，即等待另一线程。
假设T1执行c1 = 1，will_wait = 1后，T2开始执行，c2 = 1，will_wait = 2，此时T1继续执行。由于T2后执行，则T2应当等待。T1进入判断(C2 && will_wait == 1) ，此时will_wait被T2赋值为2，即T1不应等待，故T1继续执行后续代码，T2等待，直到T1释放c1置0。
